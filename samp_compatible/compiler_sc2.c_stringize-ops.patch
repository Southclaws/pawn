41a42
> #define STRINGIZE       4
1727c1728
< static const unsigned char *unpackedstring(const unsigned char *lptr,int flags)
---
> static const unsigned char *unpackedstring(const unsigned char *lptr,int *flags)
1729,1730c1730,1736
<   while (*lptr!='\"' && *lptr!='\0') {
<     if (*lptr=='\a') {          /* ignore '\a' (which was inserted at a line concatenation) */
---
>   unsigned char *stringize;
>   int instring=1;
>   if (*flags & STRINGIZE)                 /* ignore leading spaces after the # */
>     while (*lptr==' ' || *lptr=='\t')     /* this is as defines with parameters may add them */
>       lptr++;                             /* when you use a space after , in a match pattern */
>   while (*lptr!='\0') {
>     if (*lptr=='\a') {
1734c1740,1785
<     litadd(litchar(&lptr,flags | UTF8MODE));  /* litchar() alters "lptr" */
---
>     if (!instring) {
>       if (*lptr=='\"') {
>         instring=1;
>       } else if (*lptr=='#') {
>         while (*++lptr==' ' || *lptr=='\t');
>         lptr--;
>         instring=1;
>         *flags |= STRINGIZE;
>       } else if (*lptr==')' || *lptr==',' || *lptr=='}' || *lptr==';' || *lptr=='\r' || *lptr=='\n') {
>         break;
>       } else if (*lptr!=' ' && *lptr!='\t') {
>         error(1,"-string end-","-identifier-");
>         break;
>       }
>       lptr++;
>       continue;
>     }
>     if (*flags & STRINGIZE) {
>       stringize=lptr; /* check we're still in a valid stringize string */
>       while (*stringize==' ' || *stringize=='\t')
>         stringize++; /* find next non space */
>       if (*stringize=='#') { /* new stringize string */
>         lptr=stringize+1;
>         while (*lptr==' ' || *lptr=='\t')
>           lptr++;
>         continue;
>       } else if (*stringize=='\"') { /* new string */
>         lptr=stringize+1;
>         *flags &= ~STRINGIZE;
>         continue;
>       } else if (*stringize==',' || *stringize==')' || *stringize=='}' || *stringize==';') { /* end */
>         lptr=stringize;
>         break;
>       } else if (*stringize=='\0') {
>         lptr=stringize;
>         *flags &= ~STRINGIZE; /* shouldn't happen - trigger an error */
>         break;
>       }
>     } else {
>       if (*lptr=='\"') {
>         stringize=lptr++;
>         instring=0;
>         continue;
>       } /* if (*flags & STRINGIZE) */
>     }
>     litadd(litchar(&lptr,*flags | UTF8MODE));  /* litchar() alters "lptr" */
1736c1787,1790
<   litadd(0);                    /* terminate string */
---
>   litadd(0);
>   
>   if (*lptr==',' || *lptr==')' || *lptr=='}' || *lptr==';')
>     lptr=stringize;						/* backtrack to end of last string for closing " */
1740c1794
< static const unsigned char *packedstring(const unsigned char *lptr,int flags)
---
> static const unsigned char *packedstring(const unsigned char *lptr,int *flags)
1743a1798,1802
>   unsigned char *stringize;
>   int instring=1;
>   if (*flags & STRINGIZE)                     
>     while (*lptr==' ' || *lptr=='\t')
>       lptr++;
1747c1806
<   while (*lptr!='\"' && *lptr!='\0') {
---
>   while (*lptr!='\0') {
1752c1811,1856
<     c=litchar(&lptr,flags);     /* litchar() alters "lptr" */
---
>     if (!instring) {
>       if (*lptr=='\"') {
>         instring=1;
>       } else if (*lptr=='#') {
>         while (*++lptr==' ' || *lptr=='\t');
>         lptr--;
>         instring=1;
>         *flags |= STRINGIZE;
>       } else if (*lptr==')' || *lptr==',' || *lptr=='}' || *lptr==';' || *lptr=='\r' || *lptr=='\n') {
>         break;
>       } else if (*lptr!=' ' && *lptr!='\t') {
>         error(1,"-string end-","-identifier-");
>         break;
>       }
>       lptr++;
>       continue;
>     }
>     if (*flags & STRINGIZE) {
>       stringize=lptr; /* check we're still in a valid stringize string */
>       while (*stringize==' ' || *stringize=='\t')
>         stringize++; /* find next non space */
>       if (*stringize=='#') { /* new stringize string */
>         lptr=stringize+1;
>         while (*lptr==' ' || *lptr=='\t')
>           lptr++;
>         continue;
>       } else if (*stringize=='\"') { /* new string */
>         lptr=stringize+1;
>         *flags &= ~STRINGIZE;
>         continue;
>       } else if (*stringize==',' || *stringize==')' || *stringize=='}' || *stringize==';') { /* end */
>         lptr=stringize;
>         break;
>       } else if (*stringize=='\0') {
>         lptr=stringize;
>         *flags &= ~STRINGIZE; /* shouldn't happen - trigger an error */
>         break;
>       }
>     } else {
>       if (*lptr=='\"') {
>         stringize=lptr++;
>         instring=0;
>         continue;
>       } /* if (*flags & STRINGIZE) */
>     }
>     c=litchar(&lptr,*flags);     /* litchar() alters "lptr" */
1761c1865
<   } /* if */
---
>   } /* while */
1766a1871,1873
> 
>   if (*lptr==',' || *lptr==')' || *lptr=='}' || *lptr==';')
>     lptr=stringize;						/* backtrack to end of last string for closing " */
1950c2057
<   } else if (*lptr=='\"' || *lptr==sc_ctrlchar && *(lptr+1)=='\"')
---
>     } else if (*lptr=='\"' || *lptr=='#' || *lptr==sc_ctrlchar && (*(lptr+1)=='\"' || *(lptr+1)=='#'))
1953a2061
>     stringflags |= (*lptr=='#' || (*lptr==sc_ctrlchar && *(lptr+1)=='#')) ? STRINGIZE : 0;
1958c2066
<     lptr=sc_packstr ? packedstring(lptr,stringflags) : unpackedstring(lptr,stringflags);
---
>     lptr=sc_packstr ? packedstring(lptr,&stringflags) : unpackedstring(lptr,&stringflags);
1961c2069
<     else
---
>     else if (!(stringflags & STRINGIZE))
1963,1965c2071,2073
<   } else if (*lptr=='!' && *(lptr+1)=='\"'
<              || *lptr=='!' && *(lptr+1)==sc_ctrlchar && *(lptr+2)=='\"'
<              || *lptr==sc_ctrlchar && *(lptr+1)=='!' && *(lptr+2)=='\"')
---
>   } else if (*lptr=='!' && (*(lptr+1)=='\"' || *(lptr+1)=='#')
>              || *lptr=='!' && *(lptr+1)==sc_ctrlchar && (*(lptr+2)=='\"'  || *(lptr+2)=='#')
>              || *lptr==sc_ctrlchar && *(lptr+1)=='!' && (*(lptr+2)=='\"'  || *(lptr+2)=='#'))
1968c2076,2083
<     stringflags= (*lptr==sc_ctrlchar || *(lptr+1)==sc_ctrlchar) ? RAWMODE : 0;
---
>     stringflags=0;
>     if (*lptr==sc_ctrlchar || *(lptr+1)==sc_ctrlchar) {
>       stringflags=RAWMODE;
>       if (*(lptr+2)=='#')
>         stringflags |= STRINGIZE;
>     } else if (*(lptr+1)=='#') {
>       stringflags = STRINGIZE;
>     }
1973c2088
<     lptr=sc_packstr ? unpackedstring(lptr,stringflags) : packedstring(lptr,stringflags);
---
>     lptr=sc_packstr ? unpackedstring(lptr,&stringflags) : packedstring(lptr,&stringflags);
1976c2091
<     else
---
>     else if (!(stringflags & STRINGIZE))
2289a2405,2416
>         break;
>       case '#':
>       case ',':
>       case ';':
>       case ')':
>       case '}':
>         if (flags & STRINGIZE) {
>           c=*cptr;
>           cptr+=1;
>         } else {
>           error(27);    /* invalid character constant - only valid in stringize */
>         }
